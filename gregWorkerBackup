# GREG Client
import zmq
import chess
import chess.engine
import sys
import http.client
import json
import concurrent.futures
import time

# Globals

NSERVER = "catalog.cse.nd.edu:9097"
Engine  = None

# Functions

def f(i):
    return i*2

def find(info):
    print(info)
    engine = chess.engine.SimpleEngine.popen_uci("./stockfish")
    board, depth, curr_move = chess.Board(fen=info[0]), info[1], chess.Move.from_uci(info[2])
    best_move = (None, float('-inf'))
    turn = board.turn
    board.push(curr_move)
    print(type(Engine))
    print("in process")
    if depth == 0:
        score = engine.analyse(board, chess.engine.Limit(depth=0))["score"].pov(turn)
        engine.quit()
        return (curr_move.uci(), score.score()) 
    elif depth == 1:
        for move in board.pseudo_legal_moves:
            if move not in board.legal_moves:
                continue

            board.push(move)
            score = engine.analyse(board, chess.engine.Limit(depth=0))["score"].pov(turn)
            
            if best_move[1] < score.score():
                best_move = (move.uci(), score.score())
            board.pop()
        engine.quit()
        return best_move

    return (0,0)

def solve(listOfMoves, board, depth):
    bestMove = (None, float("-inf"))
    for move in listOfMoves:
        score = score_move(move, board, depth)
        print(move, score)
        if score > bestMove[1]:
            bestMove = (move, score)

    return bestMove

def score_move(move, board, depth):
    engine = chess.engine.SimpleEngine.popen_uci("./stockfish")
    turn = board.turn
    if depth == 1:
        board.push(chess.Move.from_uci(move))
        score = engine.analyse(board, chess.engine.Limit(depth=0))["score"].pov(turn).score()
        board.pop()
        engine.quit()
        return score
    else:
        # push blacks move
        board.push(chess.Move.from_uci(move))

        # push whites best move
        board.push(solve([move.uci() for move in board.pseudo_legal_moves if move in board.legal_moves], board, 1))
        
        # for every move in new board, see what is best
        return solve([move.uci() for move in board.pseudo_legal_moves if move in board.legal_moves], board, depth-1)[1]

# Classes 

class ChessWorker:
    def __init__(self):
        self.find_server()
        self.engine = chess.engine.SimpleEngine.popen_uci("./stockfish")
        global Engine
        Engine = self.engine

    def find_server(self):
        while True:
            conn = http.client.HTTPConnection(NSERVER)
            conn.request("GET", "/query.json")
            js   = json.loads(conn.getresponse().read())
            for item in js:
                if "type" in item and item["type"] == "chessWorkerBrett":
                    print(item)
                    self.port = item["port"]
                    self.host = item["name"]
                    self.connect()
                    return

    def connect(self):
        print("connect")
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.REP)
        self.socket.connect(f"tcp://{self.host}:{self.port}")
                      
    def get_jobs(self):
        while True:
            message = self.socket.recv()
            print(f"{message}")

            b = message.decode("utf-8")
            board = chess.Board(fen=b)

            moves = []
            for move in board.pseudo_legal_moves:
                if move not in board.legal_moves:
                    continue
                moves.append(move.uci())

            s = solve(moves, board, 2)

            #for b in self.get_boards(board, 1):
                #m = self.find_move(b)

            #return
            #move = self.find_move((board.fen(), 3))[0]
            
            self.socket.send(bytes(s[0], "utf-8"))

def main():
    worker = ChessWorker()
    worker.get_jobs()

if __name__ == "__main__":
    main()

# Main Execution
